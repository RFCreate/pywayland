# Copyright 2015 Sean Vig
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from operator import attrgetter
from typing import TYPE_CHECKING
from weakref import WeakKeyDictionary

from pywayland import ffi, lib

from .argument import Argument, ArgumentType

if TYPE_CHECKING:
    from collections.abc import Iterable
    from typing import Any, Callable

    from pywayland.protocol_core import Proxy

weakkeydict: WeakKeyDictionary[ffi.WlArgumentCData, tuple[ffi.CData, ...]] = (
    WeakKeyDictionary()
)


class Message:
    """Wrapper class for `wl_message` structs

    Base class that corresponds to the methods defined on an interface in the
    wayland.xml protocol, and are generated by the scanner. Subclasses specify
    the type of method, whether it is a server-side or client-side method.

    :param func: The function that is represented by the message
    :type func: Callable[..., Any]
    :param arguments: The arguments of the message
    :type arguments: tuple of :class:`~pywayland.protocol_core.Argument`
    :param version: The version of the message, or None
    :type version: int or None
    """

    def __init__(
        self,
        func: Callable[..., Any],
        arguments: tuple[Argument, ...],
        version: int | None,
    ) -> None:
        self.py_func = func

        self.name = func.__name__.strip("_")
        self.arguments = arguments
        self.version = version

    @property
    def _marshaled_arguments(self) -> Iterable[Argument]:
        for arg in self.arguments:
            if arg.interface is None and arg.argument_type == ArgumentType.NewId:
                yield Argument(ArgumentType.String)
                yield Argument(ArgumentType.Uint)
            yield arg

    def build_message_struct(
        self, wl_message_struct: ffi.WlMessageCData
    ) -> tuple[
        ffi.CharCData,
        ffi.CharCData,
        ffi.WlInterfaceCData,
    ]:
        """Bulid the wl_message struct for this message

        :param wl_message_struct:
            The wl_message cdata struct to use to build the message struct.
        :return:
            A tuple of elements which must be kept alive for the message struct
            to remain valid.
        """
        signature = "".join(argument.signature for argument in self.arguments)
        if self.version is not None:
            signature = f"{self.version}{signature}"

        name: ffi.CharCData = ffi.new("char[]", self.name.encode())
        wl_message_struct.name = name
        cdata_signature: ffi.CharCData = ffi.new("char[]", signature.encode())
        wl_message_struct.signature = cdata_signature
        types: ffi.WlInterfaceCData = ffi.new(
            "struct wl_interface* []", len(list(self._marshaled_arguments))
        )
        wl_message_struct.types = types

        for index, argument in enumerate(self._marshaled_arguments):
            if argument.interface is None:
                types[index] = ffi.NULL
            else:
                assert argument.interface._ptr is not None
                types[index] = argument.interface._ptr

        return name, cdata_signature, types

    def c_to_arguments(
        self, args_ptr: ffi.WlArgumentCData
    ) -> list[int | float | str | bytearray | Proxy[Any] | ffi.CData | None]:
        """Create a list of arguments

        Generate the arguments of the method from a CFFI cdata array of
        `wl_argument` structs that correspond to the arguments of the method as
        specified by the method signature.

        :param args_ptr: Input arguments
        :type args_ptr: cdata `union wl_argument []`
        :returns: list of args
        """
        args: list[int | float | str | bytearray | Proxy[Any] | ffi.CData | None] = []
        proxy_ptr: ffi.WlProxyCData
        for i, argument in enumerate(self.arguments):
            arg_ptr = args_ptr[i]

            # Match numbers (int, unsigned, float, file descriptor)
            if argument.argument_type == ArgumentType.Int:
                args.append(arg_ptr.i)
            elif argument.argument_type == ArgumentType.Uint:
                args.append(arg_ptr.u)
            elif argument.argument_type == ArgumentType.Fixed:
                f = lib.wl_fixed_to_double(arg_ptr.f)
                args.append(f)
            elif argument.argument_type == ArgumentType.FileDescriptor:
                args.append(arg_ptr.h)
            elif argument.argument_type == ArgumentType.String:
                if arg_ptr == ffi.NULL:
                    if not argument.nullable:
                        raise Exception
                    args.append(None)
                else:
                    args.append(ffi.string(arg_ptr.s).decode())
            elif argument.argument_type == ArgumentType.Object:
                if arg_ptr.o == ffi.NULL:
                    if not argument.nullable:
                        message = f"Got null object parsing arguments for '{self.name}' message, may already be destroyed"
                        raise RuntimeError(message)
                    args.append(None)
                else:
                    iface = argument.interface
                    if iface is None:
                        continue
                    proxy_ptr = ffi.cast("struct wl_proxy *", arg_ptr.o)
                    obj = iface.registry.get(proxy_ptr)
                    if obj is None:
                        raise RuntimeError(
                            f"Unable to get object for {proxy_ptr}, was it garbage collected?"
                        )
                    args.append(obj)
            elif argument.argument_type == ArgumentType.NewId:
                from pywayland.protocol.wayland import WlRegistry

                if (
                    display := next(
                        map(attrgetter("_display"), WlRegistry.registry.values()), None
                    )
                ) is None:
                    raise RuntimeError("Cannot find display")
                iface = argument.interface
                assert iface
                proxy_ptr = ffi.cast("struct wl_proxy *", arg_ptr.o)
                obj = iface.proxy_class(proxy_ptr, display)
                args.append(obj)
            elif argument.argument_type == ArgumentType.Array:
                array_ptr = arg_ptr.a
                args.append(ffi.buffer(array_ptr.data, array_ptr.size)[:])
            else:
                raise Exception(f"Bad argument: {argument}")

        return args

    def arguments_to_c(self, *args: Any) -> ffi.WlArgumentCData:
        """Create an array of `wl_argument` C structs

        Generate the CFFI cdata array of `wl_argument` structs that correspond
        to the arguments of the method as specified by the method signature.

        :param args: Input arguments
        :type args: `list`
        :returns: cdata `union wl_argument []` of args
        """
        nargs = len(list(self._marshaled_arguments))
        args_ptr: ffi.WlArgumentCData = ffi.new("union wl_argument []", nargs)

        arg_iter = iter(args)
        refs: list[ffi.CData] = []
        for i, argument in enumerate(self._marshaled_arguments):
            # New id (set to null for now, will be assigned on marshal)
            # Then, continue so we don't consume an arg
            if argument.argument_type == ArgumentType.NewId:
                args_ptr[i].o = ffi.NULL
                continue

            arg = next(arg_iter)
            # Match numbers (int, unsigned, float, file descriptor)
            if argument.argument_type == ArgumentType.Int:
                args_ptr[i].i = arg
            elif argument.argument_type == ArgumentType.Uint:
                args_ptr[i].u = arg
            elif argument.argument_type == ArgumentType.Fixed:
                if isinstance(arg, int):
                    f = lib.wl_fixed_from_int(arg)
                else:
                    f = lib.wl_fixed_from_double(arg)
                args_ptr[i].f = f
            elif argument.argument_type == ArgumentType.FileDescriptor:
                args_ptr[i].h = arg
            elif argument.argument_type == ArgumentType.String:
                new_string: ffi.CharCData
                if arg is None:
                    if not argument.nullable:
                        raise Exception
                    new_string = ffi.NULL
                else:
                    new_string = ffi.new("char []", arg.encode())
                    refs.append(new_string)
                args_ptr[i].s = new_string
            elif argument.argument_type == ArgumentType.Object:
                new_obj: ffi.WlObjectCData
                if arg is None:
                    if not argument.nullable:
                        raise Exception
                    new_obj = ffi.NULL
                else:
                    new_obj = ffi.cast("struct wl_object *", arg._ptr)
                    refs.append(new_obj)
                args_ptr[i].o = new_obj
            elif argument.argument_type == ArgumentType.Array:
                # TODO: this is a bit messy, we probably don't want to put everything in one buffer like this
                new_array: ffi.WlArrayCData = ffi.new("struct wl_array *")
                new_data: ffi.CData = ffi.new("void []", len(arg))
                new_array.alloc = new_array.size = len(arg)
                ffi.buffer(new_data)[:] = arg
                refs.append(new_array)
                refs.append(new_data)

        if len(refs) > 0:
            weakkeydict[args_ptr] = tuple(refs)

        return args_ptr
