# Copyright 2015 Sean Vig
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re
import textwrap

from functools import partial

head_msg = """\
# -*- coding: utf-8 -*-
# This file has been autogenerated by the pywayland scanner"""

# Match function calls wl_inter_face.function and interface names wl_interface
# while consuming any traling parentheses
re_doc = re.compile(r'(?P<iface>wl(?:_[a-z]+)+)(?P<func>\.[a-z]+(?:_[a-z]+)*)?(?:\(\))?')
tab_stop = 4


class Printer(object):
    """Base level printer object

    Allows for storing of lines to be output from the definition of a
    protocol.  Lines are added by directly calling the printer object.
    """
    def __init__(self, protocol):
        self.level = 0
        self.lines = []
        self.proto_name = protocol
        self.iface_name = None

    def __call__(self, new_line=''):
        """Add the new line to the printer"""
        if new_line:
            self.lines.append((' ' * tab_stop * self.level) + new_line)
        else:
            self.lines.append('')

    def docstring(self, docstring, module_imports):
        """Add lines as docstrings

        In addition to the operations performed by :meth:`Printer.doc()`, will
        wrap text passed to it to the correct width.
        """
        docstring = re_doc.sub(partial(self._doc_replace, module_imports=module_imports), docstring)

        paragraphs = []
        for paragraph in docstring.split('\n\n'):
            # try to detect and properly output lists
            for start_block in ('- ', '* '):
                if paragraph.lstrip().startswith(start_block):
                    # the list items are not always separated by paragraph
                    # breaks, so parse each line and see if they start with the
                    # list block
                    lines = paragraph.split('\n')
                    list_items = []
                    current_list_item = [lines[0][2:]]
                    for line in lines[1:]:
                        if line.startswith(start_block):
                            list_items.append('\n'.join(current_list_item))
                            current_list_item = [line[2:]]
                        else:
                            current_list_item.append(line)
                    list_items.append('\n'.join(current_list_item))

                    # wrap each list item
                    lines = []
                    for list_item in list_items:
                        list_item = list_item.replace('\n  ', '\n')
                        list_item_lines = textwrap.fill(list_item, 79 - tab_stop * self.level - 2).split('\n')
                        lines.append(start_block + list_item_lines[0])
                        lines.extend('  ' + line for line in list_item_lines[1:])
                    paragraphs.append('\n'.join(lines))
                    break
            else:
                paragraphs.append(
                    textwrap.fill(paragraph, 79 - tab_stop * self.level)
                )

        wrapped = '\n\n'.join(paragraphs)
        for line in wrapped.split('\n'):
            self(line)

    def doc(self, new_line, module_imports):
        """Add lines as docstrings

        Performs additional massaging of strings, replacing references to other
        protocols and protocol methods with the appropriate Sphinx
        cross-reference.
        """
        new_line = re_doc.sub(partial(self._doc_replace, module_imports=module_imports), new_line)
        self(new_line)

    def _get_iface(self, iface_name, module_imports):
        iface_class = ''.join(x.capitalize() for x in iface_name.split('_'))

        # the interface is from _this_ protocol:
        if iface_name == self.iface_name:
            iface_path = iface_class
        elif iface_class in module_imports:
            iface_path = module_imports[iface_class]
        else:
            iface_path = iface_class

        return iface_class, iface_path

    def _doc_replace(self, match, module_imports):
        iface_name = match.group('iface')
        iface, iface_path = self._get_iface(iface_name, module_imports)
        func = match.group('func')

        # annoying corner case from poorly formatted xml
        if iface_name == 'wl_pointer_destroy':
            iface = iface_name = 'Pointer'
            iface_path = 'pywayland.protocol.wayland.pointer.Pointer'
            func = '.destroy'

        if func:
            if iface_name == self.iface_name:
                return ':func:`{}{}`'.format(iface, func)
            else:
                return ':func:`{class_name}{func}() <{path}{func}>`'.format(
                    class_name=iface, func=func, path=iface_path
                )
        else:
            if iface_name == self.iface_name:
                return ':class:`{}`'.format(iface)
            else:
                return ':class:`~{}`'.format(iface_path)

    def inc_level(self):
        """Increment the indent level"""
        self.level += 1

    def dec_level(self):
        """Decrement the indent level"""
        self.level -= 1

    def initialize_file(self, iface_name=None):
        """Initialize the file by writing out the header"""
        self(head_msg)
        self()

        self.iface_name = iface_name

    def write(self, f):
        """Write the lines added to the printer out to the given file"""
        for line in self.lines:
            f.write(line.encode('utf-8'))
            f.write(b'\n')
